// OpticalFlowState.c was generated by ProtoGen version 2.17.b

#include "OpticalFlowState.h"
#include "floatspecial.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

//! Encode a flowDelta_t structure into a byte array
void encodeflowDelta_t(uint8_t* data, int* bytecount, const flowDelta_t* user);

/*!
 * \brief Encode a flowDelta_t structure into a byte array
 *

 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeflowDelta_t(uint8_t* _pg_data, int* _pg_bytecount, const flowDelta_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    int16ToBeBytes(_pg_user->x, _pg_data, &_pg_byteindex);

    int16ToBeBytes(_pg_user->y, _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// encodeflowDelta_t

//! Decode a flowDelta_t structure from a byte array
int decodeflowDelta_t(const uint8_t* data, int* bytecount, flowDelta_t* user);

/*!
 * \brief Decode a flowDelta_t structure from a byte array
 *

 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned _pg_bytecount will not be updated.
 */
int decodeflowDelta_t(const uint8_t* _pg_data, int* _pg_bytecount, flowDelta_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    _pg_user->x = int16FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->y = int16FromBeBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeflowDelta_t

/*!
 * \brief Encode a OpticalFlowState_t structure into a byte array
 *
 * Optical Flow state.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeOpticalFlowState_t(uint8_t* _pg_data, int* _pg_bytecount, const OpticalFlowState_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    uint8ToBytes(_pg_user->sequence, _pg_data, &_pg_byteindex);

    uint32ToBeBytes(_pg_user->timeDelta_us, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->isMoving, _pg_data, &_pg_byteindex);

    // surface quality
    uint8ToBytes(_pg_user->surfaceQuality, _pg_data, &_pg_byteindex);

    encodeflowDelta_t(_pg_data, &_pg_byteindex, &_pg_user->flowDelta);

    *_pg_bytecount = _pg_byteindex;

}// encodeOpticalFlowState_t

/*!
 * \brief Decode a OpticalFlowState_t structure from a byte array
 *
 * Optical Flow state.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned _pg_bytecount will not be updated.
 */
int decodeOpticalFlowState_t(const uint8_t* _pg_data, int* _pg_bytecount, OpticalFlowState_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    _pg_user->sequence = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->timeDelta_us = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->isMoving = uint8FromBytes(_pg_data, &_pg_byteindex);

    // surface quality
    _pg_user->surfaceQuality = uint8FromBytes(_pg_data, &_pg_byteindex);

    if(decodeflowDelta_t(_pg_data, &_pg_byteindex, &_pg_user->flowDelta) == 0)
        return 0;

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeOpticalFlowState_t

/*!
 * \brief Create the OpticalFlowState packet
 *
 * Optical Flow state.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeOpticalFlowStatePacketStructure(CorvoPacket* _pg_pkt, const OpticalFlowState_t* _pg_user)
{
    uint8_t* _pg_data = getPpdsMotorPodPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes(_pg_user->sequence, _pg_data, &_pg_byteindex);

    uint32ToBeBytes(_pg_user->timeDelta_us, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->isMoving, _pg_data, &_pg_byteindex);

    // surface quality
    uint8ToBytes(_pg_user->surfaceQuality, _pg_data, &_pg_byteindex);

    encodeflowDelta_t(_pg_data, &_pg_byteindex, &_pg_user->flowDelta);

    // complete the process of creating the packet
    finishPpdsMotorPodPacket(_pg_pkt, _pg_byteindex, getOpticalFlowStatePacketID());
}

/*!
 * \brief Decode the OpticalFlowState packet
 *
 * Optical Flow state.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOpticalFlowStatePacketStructure(const CorvoPacket* _pg_pkt, OpticalFlowState_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getPpdsMotorPodPacketID(_pg_pkt) != getOpticalFlowStatePacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getPpdsMotorPodPacketSize(_pg_pkt);
    if(_pg_numbytes < getOpticalFlowStateMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getPpdsMotorPodPacketDataConst(_pg_pkt);

    _pg_user->sequence = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->timeDelta_us = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->isMoving = uint8FromBytes(_pg_data, &_pg_byteindex);

    // surface quality
    _pg_user->surfaceQuality = uint8FromBytes(_pg_data, &_pg_byteindex);

    if(decodeflowDelta_t(_pg_data, &_pg_byteindex, &_pg_user->flowDelta) == 0)
        return 0;

    return 1;
}
// end of OpticalFlowState.c
